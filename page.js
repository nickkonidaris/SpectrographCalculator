// Generated by CoffeeScript 1.8.0
(function() {
  var button, renderPage;

  renderPage = function() {
    var addHeaderToForm, addToForm, form, name, _i, _len, _ref, _results;
    this.vars = {
      TELESCOPE: {
        tdiam: {
          name: "Telescope diameter [m]",
          "default": 10
        },
        tfratio: {
          name: "Telescope focal ratio []",
          "default": 15
        },
        tefl: {
          name: "Telescope focal length [m]"
        },
        tscale: {
          name: "Telescope plate scale [mm/as]"
        }
      },
      COLLIMATOR: {
        beam: {
          name: "Beam diameter [mm]",
          "default": 141
        },
        slitwidth: {
          name: "Slit width [as]",
          "default": 1
        },
        slitlength: {
          name: "FFOV [arcmin] (~ slit length)",
          "default": .1
        },
        slitlengthmm: {
          name: "FFOV [mm] (~ slit length)"
        },
        cf: {
          name: "Collimator focal length [mm]"
        },
        beamFFOV: {
          name: "Beam FFOV [&deg;]"
        },
        dthetaw: {
          name: "dtheta<sub>slit width</sub> [radian]"
        }
      },
      DISPERSER: {
        density: {
          name: "Ruling density [lines/mm]",
          "default": 1
        },
        order: {
          name: "Grating order []",
          "default": 1
        },
        l0: {
          name: "&lambda;<sub>center</sub> [&#8491;]",
          "default": 5000
        },
        lstart: {
          name: "&lambda;<sub>start</sub> [&#8491;]"
        },
        lend: {
          name: "&lambda;<sub>end</sub> [&#8491;]"
        },
        dlambda: {
          name: "d&lambda;<sub>slit width</sub> [&#8491;]"
        },
        R: {
          name: "Resolution [&lambda;<sub>center</sub>/d&lambda;<sub>slit width</sub>]"
        },
        NR: {
          name: "Number of resolution elements []"
        },
        grotate: {
          name: "Grating Rotation [&deg;]",
          "default": 22
        },
        dFFOV: {
          name: "Dispersed ffov [&deg;]"
        },
        pr: {
          name: "Minimum pupil relief [mm]"
        },
        anamorph: {
          name: "Anamorphic factor []"
        }
      },
      CAMERA: {
        cFFOV: {
          name: "Camera ffov [&deg;]"
        },
        fnum: {
          name: "Camera filled f/# []",
          "default": 2.0
        },
        camefl: {
          name: "Camera focal length [mm]"
        },
        mfnum: {
          name: "Camera underfilled f/# []"
        },
        cslitwidth: {
          name: "Camera delivered slit width [&mu;m]"
        },
        speclen: {
          name: "Spectrum length [mm]"
        }
      },
      DETECTOR: {
        pixelsize: {
          name: "Pixel size [&mu;m]",
          "default": 15
        },
        dslitwidth: {
          name: "Slit width [pix]"
        },
        speclenpix: {
          name: "Spectrum length [pix]"
        },
        pixwidth: {
          name: "Pixel width [as]"
        },
        pixheight: {
          name: "Pixel height [as]"
        }
      },
      SYSTEM: {
        effarea: {
          name: "Effective area (assume 30% thpt) [cm<sup>2</sup>]"
        },
        pixarea: {
          name: "Pixel area [as<sup>2</sup>]"
        },
        bandwidth: {
          name: "Bandwidth/pixel [&#8491;]"
        },
        pthpt: {
          name: "Pixel system throughput [as<sup>2</sup> cm<sup>2</sup> &#8491;]"
        }
      }
    };
    form = $("#frmMain");
    addToForm = function(container, varname) {
      form.append('<label title="' + tooltips[varname] + '">' + container[varname].name + " (" + varname + ")</label>");
      form.append('<input type="text" id="' + varname + '"></input><br/>');
      if (container[varname]["default"] != null) {
        return $("#" + varname)[0].value = container[varname]["default"];
      }
    };
    addHeaderToForm = function(name) {
      var objname, _i, _len, _ref, _results;
      form.append("<h2>" + name + "</h2>");
      _ref = Object.keys(vars[name]);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        objname = _ref[_i];
        _results.push(addToForm(vars[name], objname));
      }
      return _results;
    };
    this.tooltips = solversToTooltips();
    _ref = Object.keys(vars);
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      name = _ref[_i];
      _results.push(addHeaderToForm(name));
    }
    return _results;
  };

  this.drawSpectrograph = function() {
    var aZ, beam, c, camfov, cf, cfno, ctx, drawBeam, drawCamField, drawCone, dx, dy, gOrig, grotate, margin, originY, pr, scale, slitlen, tanTilt;
    c = $("#drawArea")[0];
    cf = $("#cf")[0].value;
    scale = c.width * .9 / (2 * cf);
    cf = cf * scale;
    cfno = $("#tfratio")[0].value;
    slitlen = $("#slitlength")[0].value / 60 * cf;
    beam = $("#beam")[0].value * scale;
    pr = $("#pr")[0].value * scale;
    grotate = $("#grotate")[0].value;
    camfov = $("#cFFOV")[0].value;
    console.log(scale);
    ctx = c.getContext("2d");
    ctx.clearRect(0, 0, c.width, c.height);
    margin = 25;
    drawCone = function(start, delt, height) {
      ctx.beginPath();
      ctx.moveTo(start[0], start[1]);
      ctx.lineTo(start[0] + delt[0], start[1] + delt[1] + height / 2);
      ctx.moveTo(start[0], start[1]);
      ctx.lineTo(start[0] + delt[0], start[1] + delt[1] - height / 2);
      return ctx.stroke();
    };
    drawBeam = function(start, efl, diam) {
      ctx.beginPath();
      ctx.moveTo(start[0], start[1] + diam / 2);
      ctx.lineTo(start[0] + efl, originY + diam / 2);
      ctx.moveTo(start[0], start[1] - diam / 2);
      ctx.lineTo(start[0] + efl, originY - diam / 2);
      return ctx.stroke();
    };
    ctx.beginPath();
    ctx.lineWidth = .5;
    originY = margin + slitlen / 2;
    ctx.lineTo(margin, margin);
    ctx.lineTo(margin, margin + slitlen);
    ctx.stroke();
    ctx.beginPath();
    ctx.lineWidth = .1;
    ctx.moveTo(0, originY);
    ctx.lineTo(400, originY);
    ctx.stroke();
    ctx.lineWidth = 1;
    dx = cf;
    dy = dx / cfno;
    drawCone([margin, originY], [dx, 0], dy);
    drawBeam([margin + dx, originY - slitlen / 2], dx, beam);
    drawCone([margin, margin], [dx, 0], dy);
    drawBeam([margin + dx, originY], dx, beam);
    drawCone([margin, margin + slitlen], [dx, 0], dy);
    drawBeam([margin + dx, margin + slitlen], dx, beam);
    tanTilt = Math.tan(grotate / 57.3);
    gOrig = [margin + 2 * dx, originY];
    ctx.beginPath();
    ctx.moveTo(gOrig[0], gOrig[1]);
    ctx.lineTo(gOrig[0] - tanTilt * beam / 2, gOrig[1] - beam / 2 * anamorph);
    ctx.lineTo(gOrig[0] + tanTilt * beam / 2, gOrig[1] + beam / 2 * anamorph);
    ctx.stroke();
    drawCamField = function(angle) {
      var dX, dY, offX;
      offX = beam / 2 * Math.sin(angle / 57.3);
      dX = pr * Math.cos(angle / 57.3);
      dY = pr * Math.sin(angle / 57.3);
      ctx.beginPath();
      ctx.moveTo(gOrig[0] - offX, gOrig[1] + beam / 2);
      ctx.lineTo(gOrig[0] - dX - offX, gOrig[1] - dY + beam / 2);
      ctx.moveTo(gOrig[0] + offX, gOrig[1] - beam / 2);
      ctx.lineTo(gOrig[0] - dX + offX, gOrig[1] - dY - beam / 2);
      return ctx.stroke();
    };
    aZ = grotate * 2;
    drawCamField(-aZ + camfov / 2);
    drawCamField(-aZ);
    return drawCamField(-aZ - camfov);
  };

  this.solvers = {
    telescopeSolver: new Solver({
      tdiam: 'tdiam',
      tfratio: 'tscale*206265/1000/tdiam',
      tscale: 'tdiam * tfratio / 206265. * 1000.0',
      tefl: 'tscale*206265/1000'
    }),
    collimatorSolver: new Solver({
      beam: 'beam',
      cf: 'tfratio * beam',
      slitlength: 'slitlength',
      slitlengthmm: 'beamFFOV/57.3*cf',
      slitwidth: 'slitwidth',
      beamFFOV: 'tdiam/(beam/1000.) * slitlength/60.',
      dthetaw: 'slitwidth * tscale / cf'
    }),
    disperserSolver: new Solver({
      dthetaw: 'dthetaw',
      order: 'order',
      density: 'density',
      l0: 'l0',
      lstart: 'l0-l0/(order+1)',
      lend: 'l0+l0/(order+1)',
      dlambda: 'dthetaw/(order*density*1e-7)/anamorph',
      R: 'l0/dlambda',
      NR: '(lend-lstart)/dlambda',
      dFFOV: 'NR*dthetaw*57.3',
      grotate: 'grotate',
      pr: '(anamorph*beam/2)/Math.tan((-beamFFOV/2 - dFFOV/2 + 2*grotate)/(2*57.3))',
      anamorph: '1/Math.cos(2*grotate/57.3)'
    }),
    cameraSolver: new Solver({
      cFFOV: 'Math.sqrt(dFFOV*dFFOV + beamFFOV * beamFFOV)',
      fnum: 'fnum',
      camefl: 'fnum*beam',
      mfnum: '(beam + 2*pr*Math.tan(cFFOV/(2*57.3)))/camefl',
      cslitwidth: 'camefl*dthetaw*1000/anamorph',
      speclen: 'Math.tan(dFFOV/57.3/2)*2*camefl'
    }),
    detectorSolver: new Solver({
      pixelsize: 'pixelsize',
      dslitwidth: 'cslitwidth/pixelsize',
      speclenpix: 'speclen/(pixelsize/1000)',
      pixwidth: '1/dslitwidth',
      pixheight: 'anamorph/dslitwidth'
    }),
    systemSolver: new Solver({
      effarea: '0.3*3.14*Math.pow(tdiam/2*.8, 2)*1e4',
      pixarea: 'pixwidth * pixheight',
      bandwidth: 'dlambda/dslitwidth',
      pthpt: 'pixarea*effarea*bandwidth'
    })
  };

  this.toList = function(varElement) {
    return Object.keys(varElement);
  };

  this.solversToTooltips = function() {
    var eq, eqs, solver, solvername, tooltips, _i, _j, _len, _len1, _ref;
    tooltips = {};
    console.log(solvers);
    _ref = Object.keys(solvers);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      solvername = _ref[_i];
      solver = solvers[solvername];
      eqs = Object.keys(solver.equations);
      for (_j = 0, _len1 = eqs.length; _j < _len1; _j++) {
        eq = eqs[_j];
        tooltips[eq] = solver.equations[eq];
      }
    }
    return tooltips;
  };

  this.bundleVariablesFromDOM = function() {
    var allVars, el, flt, popVars, value, varElement, _i, _j, _len, _len1, _ref;
    popVars = {};
    _ref = toList(vars);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      varElement = _ref[_i];
      allVars = toList(vars[varElement]);
      for (_j = 0, _len1 = allVars.length; _j < _len1; _j++) {
        el = allVars[_j];
        value = $("#" + el)[0].value;
        flt = parseFloat(value);
        if (value !== "" && !isNaN(flt)) {
          popVars[el] = parseFloat(flt);
        }
      }
    }
    return popVars;
  };

  this.populateForm = function(solution) {
    var el, vars, _i, _len, _results;
    vars = Object.keys(solution);
    _results = [];
    for (_i = 0, _len = vars.length; _i < _len; _i++) {
      el = vars[_i];
      _results.push($("#" + el)[0].value = solution[el]);
    }
    return _results;
  };

  this.handleSolve = function() {
    var bundle, solution;
    bundle = bundleVariablesFromDOM(vars);
    console.log(bundle);
    solution = solvers.telescopeSolver.solve(bundle);
    populateForm(solution);
    solution = solvers.collimatorSolver.solve(bundle);
    populateForm(solution);
    solution = solvers.disperserSolver.solve(bundle);
    populateForm(solution);
    solution = solvers.cameraSolver.solve(bundle);
    populateForm(solution);
    solution = solvers.detectorSolver.solve(bundle);
    populateForm(solution);
    solution = solvers.systemSolver.solve(bundle);
    return populateForm(solution);
  };

  this.doSolve = function() {
    handleSolve();
    handleSolve();
    handleSolve();
    handleSolve();
    handleSolve();
    handleSolve();
    handleSolve();
    return drawSpectrograph();
  };

  button = $("#handleSolve");

  button.onclick = handleSolve;

  renderPage();

}).call(this);
